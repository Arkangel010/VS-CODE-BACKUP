Recursion - When a function calls itself,until a specified condition is met.
	    Calling same function again and again but with smaller input in called Recursion.


ulta socho, kisi bhi problem ka small test case lo aur  usko normally karo, phir last few steps me repititions of work aur easiest work dekho.

(i) Under stand the problem 
(ii) Play with some test cases and think like lemman apporach.(when the ans is equal to the input that is basically reffered to as base case) 

(iii) under stand the pattern and for the played test cases.
(iv) Try to see the increasing pattern in order to find the n term.



Sabse aasan kaam mai karunga aur baki function karega.

(recursion tree)

Steps to solve 

(i) Identify - if we make a function which can do a work and it can perform same work for larger input. Ek hi kaam ko same function kar sakta hai for different inputs.E.g agar ek function 4 ka factorial deta hai aur wahi function n ka bhi factorial de sakta hai.
(ii)Do small work.
(iii) Ask recursion to do remaining work.
(iv) Base condition

Steps to work:

(i) Base case - Smallest valid input.
(ii) Recursive call
(iii) Small work

ways of recursion: 
(i) Parametrised - When the function returns nothing and function is recalled, this condition is reffered to a parametrised recursion.
(ii) Functional - When we return something from and function and do recursion as well it is reffered to as functional recursion.

-Subsequences(Power Set)

 A contiguous/Non - contiguous sequences, which follows the order.

Ex - {1, 2, 3}

subsequences : {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, {1, 2, 3} , {} 
but {3, 2} , {3, 1} - Not a susequence because doesn't follow the order.

In order to make algo : take an element at once and remove others, assume you go to a mall and in order to try n no of dresses you need to remove the previous dress and put on the new one.

Recursive Leaf of Faith : Assume simpler cases work out.

Ask yourself :
(i) Whats the simplest possible input ?
(ii)Play around with examples and visualize!
(iii) Relate hard cases to simpler cases'
(iv) Generalize the pattern.
(v) Write the code by combining recursive pattern with the base case.


Think less at time of solving recursive problem.


(i) Dont jump to code 
(ii) understand the problem statement 
(iii) Break the problem statement into test case
(iv) Try to dry run the test case 
(v) Try to build the logic 


(For Combinations Problems, first think in leman terms of placing things as per the concept of Permutation and combination) 
If there are fixed choices at every position = no of recursive calls in code is equal to no. of choices.

(i) number of choices at each pos
(ii) if choices is fixed 
(iii) no of recursive calls = no of choices
(iv) Example


-Backtracking

It is a technique for solving problems recursively to build the solution incremently, one piece at a time , removing the solutions that failed to satisfy the constraints at ant point of time.


Types of Backtracking problem

(i) Decision Problem - In this we search for a feasible solution -> possible solution -> Solution which is going to work for us.

(ii) Optimization Problem - In this we look for the solution which is best for us.

(iii) Enumeration Problem - Collection of all the feasible solutions.



Way to draw Stack call in order to see working of recursion
 ----- Line of function call 
 |
|  |Func call with args |
------------------------
|  |                   	|
|  |                   	|
|  |                   	|
|  |              	|
|  |             	|
|  |             	|
|  |              	|
-------------------------


(i) Read the problem, break it line by line.
(ii) Deduce its short form with the given data.
(iii) Think about the approaches.
(iv) Dry run on pen pen paper.
(v) write code and debug.
(vi) think for exceptional cases and failure cases.
(v) run the code 
(vi) Submit.


----------------

Recursion has two levels

(i) High Level Thinking 

(a) Establish the Expectation 
(b) Establish the faith 
(c) Link Expectation and faith 

(ii) Low Level Thinking

(a) Dry Run 
(b) Fill the Stack

PMI

(i) Assume that the formula is true for k.
(ii) Prove that formula holds true for n = k + 1.
(iii) Try to make the LHS equal to the rhs wih the help of the RHS.
(iv) Prove for n = 1.

Ways To do/Think recursive Problems:

(i) Faith - Expectation way: In this we first declare the Expectation from the function and then the faith and then we meet the Expectation by the help of faith.
Isme pehle upar jate hain aur niche aate samaye problem solve karte hain.

(ii) Level - Option way : In this we keep solving the problem piece/step by piece/step and get the answer.
Isme upar jate ke sath sath problem solve karte jate hai.In this the parameters are reffered to as levels and the recursive calls are the options.

Note: when there is recursive call within a function then the code within the function is divided into two parts :

(i) The upper part (from the recursive call line) - Runs until the base case is hit.
(ii) The Lower part (from the recursive call line) - Runs after the base case is hit.

Pattern
Touch every topic


(i) One Recursive call 
upper code [Initiates when code is expanding according to the calls within the argument]
recursive call 
lower code [Initiates when code is returning after the work/line of work is finished.

(ii) Two Recursive call 

code (Pre region)
recursive call 1 [Left call]
code (In region)
recursive call 2 [Right call]
code (Post region) 


In order to analyze Two Recursive call we draw Euler Tree and by the help of Eular Path we can detertimine the flow by a line starting from the pre area to in area to post area.

Example:- 

void fun(int n){
cout << "Pre" <<  n;

fun(n - 1);

cout << "In" << n;

fun(n - 1);

cout << "Post" << n;

}

for n = 2:



	   0		     0
	   |		     |
           1 	(in Area)    1
(left call)|-----------------|(right call)
		     |
          (pre area) 2 (post area)

pattern 

(i) Single Recursive call relatively loop
(ii) Double Recursive call



(i) Let say a function is made to do the task you want it to do.

(ii) Then see for smaller input that if the function works for the particular situation. Like we do in PMI assume f(k) is true.

(iii) Then see that it works for the particular test case.

(iv) Then prove that the function works for the smallest input.


Note very important : Suspension of disbelief.

Try to make a function according to the need and break down the problem in subproblem according to the function working and solve the sub problem and then the overall problem.

- Source to destination problem

(i) Visualize/Draw the possible ways by the help of the reaching the destination by the help of the Euler Tree.Express the levels and options using the Euler Tree.
(ii) Form the Recursive calls by the help of the possible ways.
(iii)If you can get the ans/array of way after effort 1 then just add 1 and just return array by adding the effort 1 in front.

-Printing Ways Problem

(i) Always see the program output in the no of possibility of an object within the Answer to be printed.

(ii) Write the code accordingly to the possibilties found so far.

*Ek baar lo , ek baar mat lo.

 