basic

#include<stdio.h>
int main(){
//code
}

Important 
\0 or NULL singnifies null whithin c.
Static Access modifier - It is intialised once and its value stored within the heap memory specificily such that its scope is through out the program.
heap - Static variable  
Stack - (int,char,float) variable 
return - It retuns processing queue to the place from where the function was called.
typedef - It is a keyword to used to give a datatype a desired Name. (typedef Datatype DesiredName;).
stdlib.h - contains free ,memory allocation functions (malloc ,abort,exit)
typecasting : Process of converting one datatype to another.
 Syntax
Datatype Variable = (Datatype the after Braccket value need to be conveted in) Value;
c programming : It is high level language which is used to give instructiions to the computer.

 
The working process is : .c file - .obj file - compiler - machine language - computer

In low level language (Machine language,Assembly Language) portability is not feasible.

Feature 

-High level language
-Case Sensitive 
-Small language having 32 Keywords
-Portable
-Built in fuctions  & operators
-Pointers
-Dynamic Memory allocation
-Modular Programming
-Platform dependent

Structure of Program 

1.Documentation section - It will contain the author name,code writer etc by help of comments function (// ,/* */ ).

2.Link Section - We include header files  e.g. #include <stdio.h> .Here # is a preprocesser . Basically it is the set of predefined functions and in order to initialize the functions we use link section. 
e.g. - 1. #include <stdio.h> - Full form - Standard Input Output. (.h) shows that it is a header file.
       2. #include <conio.h> -  console Input output. (getch(); - It the function of conio.h that is used to hold the output screen.)
       3. #include <math.h> - For math fuctions.
       4. #include <string.h> - For string functions.
3.Definition Section - we declare varibles.
4.Global declaration section - variables that are used within multiple function and declared outside all the functions. It is decalred outside main after definition section.
5.Main section - It contains variables and functions of executable part. 
6.Sub Program Section - It is the user defined fuction comes after the main section.

Constant 

These are variables whose value doesnt change throughout program.

syntax:
1 way
const datatype variableName = value ;
2nd way (constant Name should be in capital, No semi colon is requierd)
#define constantName value 


Variable 
It is a combination of memory and value within the computer.

syntax:(we can intialize the variable at time of declaration also,according to requirement and situation we do so)
1.Declare
Datatype variableName; 

2.To Initalize
VariabeName = value;


Identifiers & Keywords(32 Keywords)

int,float,break,goto,if,for,continue,double,while,do,switch,auto,etc

Indentifiers - Variable Name is generally defined as indentifiers.Keywords cant be used as vaiable name. 

DataTypes in c 

Primary ->int,float,char,double,void
Derived ->Array,Structure,union,Pointers 
User Defined ->type def,Enumerated Datatype (type def in this we remname datatype as our desired name.typedef int aman; ,now inplace of int we can use aman)

Signed Integers - It is a format specifier.Integers that can store only +ve  & -ve value is known as signed Integers.It is attained by using the format specifier %d.
Unsigned Integers - It is a format specifier.Integer that can store only +ve value.It is attained by using the format specifier %u.

Operators

Types of operator based on operants

1.Unary operaotr -> -(unary minus),++ ,--(increment,decrement operator),!(logical not),&(address of operator),sizeof(); (It is used to get size of variable in bytes)
2.Binary operator -> -,+,/,* (Arithematic operators), = (assignment operator ,precidency - Left to Right), += ,-= ,*=,/= (shorthand oprerator)
                     <,>,<=,>= (Relational operator,It compares the address of the given value.It is basically use to compare int,float,char data,precidency - Left to Right), ==,!=(Equality Operator) 
                     &&(and),||(or) {Logical operator,Used basically to apply two expressions at a time)
                     Bitwise operator - &(Bitwise and),|(Bitwise OR),^(Bitwise XOR),`(Bitwise Not),<<(Left wise),>>(Right Shift)
                     1.Convert decimal to binary.
                     2.Compare two binary no (for & operator, 0 and 1 = 0 , 0 and 0 = 1 , 1 and 1 = 1,for | operator, 0 and 1 = 1 , 0 and 0 = 0 , 1 and 1 = 0 ,for ^ operator, 0 and 1 = 1 , 0 and 0 = 0 , 1 and 1 = 0,for ` operator, 0 = 1 , 1 = 0 , for << operator the bytes shift to the left 0 replaces the empty places,for >> operator the bytes shift to the left 0 replaces the empty places)
                     3.derive the output 
3.Special Operators -> comma operator(,) - In this the value before comma will be executed and rejected and value after comma will be executed and assigned to the variable.
                       Note: comma has the least precidency and hence it executes itself at last.

Operator Precidency

Decreasing Precidency of operators top to bottom.


        Operators           (If multiple operator in a expression)                  

() . -> ++ -- (postfix)                    L -> R
++ --(prefix) + - ! ` * & sizeof(type)     R -> L
* / %                                      L -> R
+ -                                        L -> R
<< >>                                      L -> R
< <= > >=                                  L -> R  
== !=                                      L -> R
&                                          L -> R
^                                          L -> R
|                                          L -> R
&&                                         L -> R
||                                         L -> R
?:                                         R -> L
= += -= /= %= *= ^= >>= <<=                R -> L
,                                          L -> R
                   
Formatted Input Function 

scanf function is used to take input from the user.
 syntax:
scanf("%fileSpecifier",&Variable); 

Formatted Output Function 

printf function is used to print output on the screen.

Syntax

printf("string/%formatSpecifier",Argument/VariableName )

Unformatted Input Functions 

getchar() -It is used to read character,in this we input the value and press enter.
getch() - It is used to take input in the form of password.
getche() - It 
gets() - It is used to take input of string.

Unformatted Output Functions

Putchar(); - It is used to print a character.It comes in stdio header file.
putch(); - It is used to 
puts(); - It is used to print stream of characters.It comes in stdio header file.

Control Statements 

If statement - It used for conditon based requirements.

syntax:
if( Condition ) {
//code
}

-If else

-If - elseif - else 

- switch statement 


Loop 
Repetition of a particular task is known as Loop.

Entry Controlled loops - First the termination condition is checked at starting and then the body(block code) is executed.

Exit controlled loops - First the body( block code) is executed and then the condition is checked.


For loop - It is a entry controlled loop.
syntax 
for(intialization;condition;update/modify){
//code
}

While loop 

It is a Entry controlled loop.
Syntax

while(conditon){
//code
}

Do While Loop 
It  is a Exit controlled Statement 
Syntax

do{
statement block;
}while(condtion);


Break Statement 
It is used to stop a loop as per our needs by the use of break; statement within the loop.It directly throws out of the loop.

Continue Statement 
It jumps the loop to start the loop with new iteration ignoring the rest statements after continue statement.



Array 

An array is a collection of items of same data type stored at contiguous memory locations.

Syntax 

1.Declaration/Initialiazation 
DataType ArrayName[size];

2.Defination

(i) At time of initialization
DataType ArrayName[] = {Value};

(ii) Defining particular elements after defining
ArrayName[Index] = value;

Memory Location of Particular Element = Base address + (index * size of DataType)

2-D Array 
It is an array of several 1-D array.
Syntax

1.Initialization/Declaration
Datatype NameOfArray[Rowsize][ColoumnSize]

2.Defination
 (i) ArrayName[Row][coloumn] = value;

 (ii)At time of Declaration 
      DataType ArrayName[RowSize][ColoumnSize] = {{Row1 Value},{Row2 Value},{RowNth Value}};

String
It is array of characters which ends with a null character.Format Sprecifier for string is %s

Syntax 
1.Declaration
Char StringName[Size] ;

2.Initalization
char StringName[] = "String";

Note:The size of array is the no of characters within the string + 1(for a null character always added by default).

Formatted Sring of Input 

gets() - It is a function which helps us to take input of string with the spacing in between the string and whenever enter is pressed it will store the string.

scanf() - It also takes the input for string function but within this the space character within the string makes charcter after the space character as garbage value and when we print we get only values before the space character.
 
Demerits of using such function 

-Buffer overflow - The above function will store more character than detetmined and also print the following.It will occupy random memory to store the extra characters and the random mermory might have some prestored important data ,resulting to data loss.

Formatted output of string

puts(String); - It adds a new line operator and when we print another string it is directly printed in next line.


Predefined Functions(In String header file)

strlen(String) - It is used to get the length of string.It comes in string.h header file.

strcat(String1,String2); - It is used to add to strings.It comes in string.h header file.

strcmp(Strin1,String2); - It is used to compare two strings.It comes in string.h header file.

strrev(String); - It is used to reverse  a string.
A pointer variable points to a data type (like int) of the same type, and is created with the * operator.
strlwr(String); - It is used to convert upper case string to lower case string.

Pointers 

A pointer is a variable that stores the memory address of another variable as its value.A pointer variable points to a data type (like int) of the same type, and is created with the * operator.
It is a derived datatype.
Syntax 
1.Declaration 
Datatype* PointerName;  |  same (The datatype is datatype of variable whose address it is going to store,Use & operator to get the address of a variable)
Datatype *PointerName;  |       (use * (Indirection/Dereferncing operator to print value at pointers address) )
Datatype * PointerName; |       (use %x to format specifier to print address of pointer in hexadecimal form,Use %u format specifier to print address in unsigned variable form) )

2.Initialization 
PointerName = &VariableName;

Double Pointer (Pointer to Pointer)
It is a variable that stores the address of other pointer variable.

1.Declaration
Datatype **DoublePointerName = &pointer address;

Note:Use *(indirection/Dereferencing Operator to assign values)

Pointer Arthmetics

Addition - we can only add intergers within a pointer variable(mainly used in array),but we cant add two pointer variables.
           
Substraction - we can subtract integers as well as pointer variable from the pointer variable mainly used in an array.

Increament/Decrement Operator - The pointer will  point the address of the preceiding or decreasing address within an array.


Types of Pointer

Void Pointer - The void pointer in C is a pointer that is not associated with any data types. It points to some data location in the storage. This means that it points to the address of variables. It is also called the general purpose pointer.
               It cant be derefrenced directly,it can be done by type casting.Way to do typecasting:
               
               *(Datatype*)VoidPointerName
Syntax 
1.Declaration 
Void * PointerName;

2.Initialization
Pointername = &VariableName;


use: Suppose we have multiple varibles with different datatypes so by use of void pointer we can create multiple variable pointer and just do typecasting at print time or derefrencing time.
   
Null Pointer 

A Null Pointer is a pointer that does not point to any memory location. It stores the base address of the segment.

Syntax 
Datatype *PointerName = NULL;

Dangling Pointer 

when we free/Delete the value or address using free(Variable); function but the address of the freed memory resides within the pointer is considered as Dangling Pointer.
In onder to avoid such situation we can intialize such pointer as Null pointer.

Wild Pointer 

UnInitialised Pointer is considered as wild pointer.In order to avoid such situation use Null pointer.

Function 

It is a block of code that runs only when it is called.If we pass arugument within the function when we have not declalared any datatype or void argument while declaring the variable it would not give an error if argument is passed within the function while calling in the main function.

Syntax

1.Declare Function before or in main function(if you do this the function scope will only within th emain function)
Returntype FunctionName(ArgumentDatatype);

2. Call the function in main function
FunctionName(Argument Value);


3.Define the function after main function
Datatype FunctionName(Datatype ArgumentName){
//code
}


Call by Value - Within in a function when we declare variable and then pass argument within the function then it is refferd to as call by value function.In this a copy of the variable declared within the argument of the function is formed within the block of code and the variable scope is just within the block.

Call by Reference - Within in a function by the use of *(indirection Operator) we pass argument And when there is a change in the variable within the definition of the function the change takes place within the variable declared outside the function.

Classification of Function(on basis of Return Type & Argument )

-Passing Array as an Argument
1.Declaration

Datatype FunctionName(ArrayDataType[]);

2.Initialization in main Function
FunctionName(ArrayName);

3.Definition
DataType FunctionName(ArrayDataType ArrayName[]){
//code 
}

-Passing string as an Argument 
1.Declaration

void FunctionName(char[]);

2.Initialization in main Function
FunctionName(ArrayName);

3.Definition
void FunctionName(char ArrayName[]){
//code 
}

-Returning a string from Function(use of heap and stack area concept)

1.Declaration

char* FunctionName();

2.Initialization in main Function
FunctionName(ArrayName);

3.Definition
char* FunctionName(){
char* ArrayName[] = "String";
return Array;
}


-Return Pointer from Pointer

Use ReturnType as a pointer datatype 

-Function Pointer
It is used to make a pointer of function.We can also create an function pointer array(void (*fpt[])(ArgumentDatatype) ={functionName}; and Through a single pointer we call multiple pointer(*FunctionPointerName[index])(ArgumentData); .
Retuntype (*PointerName)(DatatypeOfArgument) = &FunctionName;

Callback Function

When we pass function within a function it is reffered to as callback function.

-Recursion 

When a function calls itself within a function it is refferd to as Recursion.By the use of if-else statement we define the limit of the recursion and with the help of return keyword we control flow of code. 
It can be used in place of loops.

Types of Recursion

1.Direct Recursion - When a function calls itself directly within itself it is considered as direct recursion.

2.Indirect Recusion - when a function calls itself indirectly or when it calls another function within the function it calls itself it is considered as Indirect Recursion.

3.Tail Recursion - when there is no statement after the recursive call it is reffered to as tail recursion.

4.Non-Tail Recursion - when there is statement after the recursive call it is reffered to as tail recursion.
 

-Structure

It is a user defined datatype that is a collection of different variabes with different Datatypes under a single Name   
Contiguous Mermory Allocation is there.
Syntax
1.Declaration

struct StructureTag {
  //Members of stucture(different variabels with different datatypes,Two members cant have same name)
};

2.Object creation 

(i)In main function  or outside  the main function
struct StructureTag ObjectName;

(ii)While declaring only 
    struct StructureTag {
  //Members of stucture(different variabels with different datatypes,Two members cant have same name)
}ObjectName1,ObjectName2;

Note: If we dont give a StructureTag to a structure it is valid but within the main function we cant create a new object ,thus the object created by method 2 is only present.

3.Object Initialization 
(i)At time of object creation in main function or outside  the main function
struct StructureTag ObjectName = {value in the form of declared variable by the use of comma operator};

(ii)At time of stucture datatype creation 
 
struct StructureTag {
  //Members of stucture(different variabels with different datatypes,Two members cant have same name)
}ObjectName = {value in the form of declared variable by the use of comma operator};

(iii)By individual vaiables
ObjectName.VaraibleName = value;
4.Access of structure variables
By the help of object we can access the invidual variables.

ObejectName.VariableName;

(iv)Desiginated Intialization(the value will be given to particular variable regardless of following object variable sequence.
struct StructureTag ObjectName = { .ParticularVaraiableName = value}

-Array of Structure 
Used to store values of multiple object.

struct StructureTag ArrayName[Size];

-Structure Pointer

(i)Declaration

struct StructureTag *PointerName;

(ii)Accessing individual variable through pointer

PointerName->VariableName; or (*PointerName).VariableName;
Note: -> indicates arrow operator 

- Union

It is a user defined datatype that contains collection of different varaibles with different datatypes.
Memory allocation of size of Variable with largest storage value is created and at the single/shared  allocated memory the values of members is stored but the last member/Variable is just stored and above member/variable values are discarded.
It is not used now a days as memory was costly in earlier days hence union was used but nowadays memory is cheap thus not used.In this the due shared memory the values of all variables are updated at once.

Syntax
1.Declaration

union DatatypeName {
  //Members of union(different variabels with different datatypes,Two members cant have same name)
};

2.Object creation 

(i)In main function  or outside  the main function
union UnionTag ObjectName;

(ii)While declaring only 
    union UnionTag {
  //Members of union(different variabels with different datatypes,Two members cant have same name)
}ObjectName1,ObjectName2;

Note: If we dont give a UnionTag to a union it is valid but within the main function we cant create a new object ,thus the object created by method 2 is only present.

3.Object Initialization 
(i)At time of object creation in main function or outside  the main function
union UnionTag ObjectName = {value in the form of declared variable by the use of comma operator};

(ii)At time of union datatype creation 
 
union UnionTag {
  //Members of union(different variabels with different datatypes,Two members cant have same name)
}ObjectName = {value in the form of declared variable by the use of comma operator};

(iii)By individual vaiables
ObjectName.VaraibleName = value;
4.Access of union variables(the last initialised variable will ony give the actual value other preinitialised variables would give garbage or null value)
By the help of object we can access the invidual variables.

ObejectName.VariableName;

-Union Pointer
(i)Declaration

union UnionTag *PointerName;

(ii)Accessing individual variable through pointer

PointerName->VariableName; or (*PointerName).VariableName;
Note: -> indicates arrow operator 

-Typedefined Structure 

We can use typedef keyword in order to reduce code length.If we put typedef keyword before struct keyword in structure datatype and after closing parenthesis write a desired Structure datatype Name.

typedef struct StructureTag {
//members
}DatatypeName;

Note: In place of datatypeName in order to create object.The DatatypeName before opening parenthesis and after closing parnthesis need not to be same.

-Structure Padding 
It is used to increase the cpu speed by the penalty of memory.Within a 32bit system(4 bytes reading cability) if the data is stored in a contiguous memory the cpu has perform multiple cycle to fetch the data and this is avoided by structure padding.
It is automatically done by the compiler.

-Structure Packing 
It is used to reduce memory usage by the penalty of cpu speed.
To implement this include after header files.

#pragma pack(1)


File Handling 

File - It is sequence of bytes.It is used to store data in hard disk permanently.
File Handling: The process of storing or fetching data from hard disk in order to edit,store or fetch data.

Types of files
Text files(.text) - Easily created data files with accessibility to read as well as write and hence less secure.
Binary files(.bin)- In form of binary language ,generally reffered to as compiled form of .text form in form of machine language.

File Pointer
It points at the file within the harddisk.
syntax 
FILE *PointerName;  

fopen("FileName","mode") - It is a fuction that returns a pointer to a file sturcture used to open a file.It accepts two arguments FileName(It is the name /Location of the file) and mode (It defines the accesibility).
fclose(filePointerName);
There are 6 Modes:

r - It is used to just read mode.
w - It is used to just write mode.
a - 
r+
w+
a+

we have to store the pointer address of the file returned by fopen within a pointer.so after creating a pointer we store value returned by fopen in that.
PointerName = fopen("FileName","mode");

-write mode("w" mode) something in a file(after pointer,intializig it with fopen() fn)(No need of pre existing file and it would first create a new file and open it)

It is used to write within a file.

FilePointerName = fopen(fileName,"w");
1.fputc(CharacterVaraibleName,FilePointer) - It is used to write a single character to a file.
2.fputs(StringVaraibleName,FilePointer)- It is used to write a complete string within a fie
3.fprintf(FilePointer,"FormatSpecifier",Variable/argunment) - It as also known as formatted output.It can be used to specifiy multiple type of data by a single function with the use of format specifier.


-Read mode ("r" mode) a file(after creating file pointer,initializing it with fopen() fn)(File needs to pre created)

It is used to read a file.

FilePointerName = fopen(fileName,"r");
1.fgetc(filePointerName) - It is used to read a character from a file.It needs to be stored in a variable to diplayed on console or needs to directly printed.
                           In order to read a string we will have to implement a loop by the help of function feof(FilePointerName) (This function specifies the end of file and return type is boolean).

2.fgets(string,NoOfCharacterToBeRead,filePointerName) - It is used to read a string from a file.It needs to be stored in a array to diplayed on console or needs to directly printed.If your read value is n then the actual no of characters will be (n-1) ,1 character will be null.In order to read a whole paragraph we will have to apply a loop by help of of function feof(FilePointerName) (This function specifies the end of file and return type is boolean).

3.fscanf(FilePointer,FormatSpecifier,VaraibeStoringName); - It is used to read a complete line.

-Append ("a" mode)(adding character/string)(when we use write mode the previous data is deleted)(after creating file pointer,initializing it with fopen() fn)

It is used to add within the end of file.

FilePointerName = fopen(fileName,"a");
use write function method to add data .The pointer of appending will at the end of file .


rewind() - It is a function which shifts the cursor from ending of text file to starting of the file.Basically when we append(a+),write(W+) or modify(r+) the cursor is at the end or at random place after the process and in order to read the file we use rewind.
-R+ Mode("r+")(File needs to pre created)

It opens the file in read and write mode.It is basically used to modify the file,by default the modifying pointer is at the starting of the file.
use read and write function to modify.

-W+ mode 

It opens the file in read and write mode.No need of pre existing file and it would first create a new file and open it.If file exist,it will open file but previous content is erased.
After writing of string or character the cursor is at end of file so in order to read we have to use a function rewind(PointerName) in order to place the pointer at intial position.
After that apply readin logic.

-A+ Mode

It opens the file in read and append mode.No need of pre existing file and it would first create a new file and open it.
Use append functions to append and read functions to read.

-Special Functions

fseek(FilePointer,offset,position) - It a function used to move cursor to a specific position.It returns integer datatype( 0 = succesfully executed,not zero value = not executed).At place of offset the we write the no of bytes we want to move within the text,use (-ve sign) to move the cursor backward.At place of position we specify that from where we want to move the specified cursor within the file
                                                                                                                                                                                                                                                                         1.SEEK_SET - Cursor from begning of file.                                                
ftell(FilePointer) - It is used to find the current position of function with reference to the begining of the file.Its return type is long int.

rewind(FilePointer) - It is used to return to the cursor to the beginning of the file.                                                                                                                                                                                                                                                                         2.SEEK_CUR - Cursor form the current position. 

feof(FilePointer) - It is used to check the end of file.It return type is boolean.        

EOF - It is a keyword that specifies End of file just similar to Null keyword.

Note:Do check after opening a file the line is executed successfully or not by use of if statement and remember to close the file.
1.if(FilePointer == Null){
   	printf("error");
      exit(1);
	}
2.fclose(FilePointer);

-Program to count no of lines in a file

1.Create file pointer,and a variable count.
2.Open file in read mode.
3.Initailize a loop which runs till the end of file.
4.within the loop check condition if the upcoming character is equal to '\n') and increase count.
   

-Program to copy content of a file into another file
1.Declare two file pointer.
2.Declare a char varaible.
3.Open file 1 in read mode.
4.Open file 2 in write mode.
5.Initialize a loop to check the end of file.
           while((c=fgets(filePointer1))!=EOF){
			fputc(charVariable,FilePointer2);
                  }
5.Close both the files.

-Memory Allocation

Static memory allocation(SMA) - Memory is allocated at compile time.Fixed calculated memory is assigned according to the multiple Variables/Array or any Data used within the code and assigned within the RAM,thus cannt be altered/Reduced(if assigned value is not fully used in the code) according to need or requirement and remains fixed.It limits the reusage of memory.
Dynamic Memory Allocation(DMA) - Memory is allocated at run time.In this memory can be altered or reduced according to our needs.DMA is always done from heap.
                                 DMA cant be used without the use of pointer.We need to free the Dynamic memory if not in use by the used of free(PointerName); function,else the alloted memory will remain within the code.
Memory section



==================
|      Heap      |
==================    
|      Stack     |
==================
|  Static/Global |
==================
|code/Instruction|
==================

1.Heap - It is a pool of free memory,which can be allocated or deallocated at runtime.DMA is always done by the use of heap memory.
2.Stack - All local variables and functions take memory from stack.(Heap is inversely proportional to stack.)
3.Global/Static 
4.Code/text 

-DMA using malloc()(In stdlib.h)

malloc - Memory Allocation 
Generally used for allocation of memory for strucutres.Its return type is base address(void pointer),hence we have to use pointer and typecasting is reuired to store value.

malloc(n*sizeof(Datatype)); - We dont specify size directly as size(it creates single block of specified function)of different datatypes differ from machine to machine and hence we use sizeof function which returns the size of datatype according to machine and N signifies the no of values of particular datatype.(e.g. 3 *int) .Values are stored from the base address by the common increase structures of size of specified datatype(Similar to an array),use pointer arthmatics along with dereferencing operator to access the values.
                                                                                                                                                                                                                                                                        
TypeCasting (void Pointer  to Specified datatype pointer.)

PointerName = (Datatype*)malloc(sizeof(Datatype));

Note:Remember to free the memory after use.


-DMA using calloc()(In stdlib.h)

calloc - Contiguous allocation,Built in function,Used to dynamically allocate multiple blocks of memory & each block is of same size.
calloc(No of blocks,sizeof(Datatype));
In accepts two argument No of blocks and Memory size(sizeof(Datatype)).Each block is of same size and in contiguous form will be initialised.Its return type is base address(void Pointer),hence we have to use pointer and typecasting is reuired to store value.Values are stored from the base address by the common increase structures of size of specified datatype(Similar to an array),use pointer arthmatics along with dereferencing operator to access the values. 

-realloc()

It is used to resize the previously allocated memory.Its return type is void pointer,use typecasting.
realloc(pointer,n*sizeof(Datatype));

-Free Function(free(FilePointer))

It is used to release dynamically allocated memory.

Memory Leak 

Due to improper use of heap memory.If we dont free(deallocate) the memory and there is multiple times creation of memory and this will lead to garbage value creation. 


Enum 
User - Defined data type to assign names to integral constants.

Syntax

1.create Enum Datatype
enum EnumTag{ value};

2.create object in main function

enum EnumTag ObjectName;


-Storage Classes 

It tells about the default value,scope,location,lifteime.

Types of storage classes

1.Auto storage class(default storage class)

default value: Garbage value;
scope: Fuction,block scope allowed
location: Stack (RAM)
lifetime: Within the Block

Syntax 
auto Datatype VariableName = value ;

2.Register storage class
The instruction is loaded within the CPU register and then processing is done by the help of ALU present within the cpu.Step by step code is initialised from RAM to CPU Register (commonly known as switching) thus this reduces the Runtime and hence more efficiency,But the size of Register is very less(Kbs) so all variables cant be stored in register.So the variables which have frequent use is used as register variable(e.g. loop variables).

default value: Garbage value;
scope: Fuction/method,block scope allowed
location: CPU Register 
lifetime: Within the Block

Syntax 
register Datatype VariableName = value ;

3.Static storage class
It is Initialised once when the code is runned and it retains it previous value if reinitialised. 

default value: 0
scope: block scope allowed
location: RAM
lifetime: Till the the end of the program.

Syntax 
static Datatype VariableName = value ;

4.Extern storage class
It enabels us to access the variable whether it is written before or after main function. If we want a variable/Function we want to access the variable from one file to another then we use extern and remember to #include"FirstFileName/FileCompleteDirectory".
default value: 0 
scope:only Global scope allowed
location: RAM 
lifetime: Till the the end of the program.

Syntax 
extern Datatype VariableName = value ;

-Pre-Processer(#)

It a step in the compilation process(text substitution tool).The compiler doesnt understand the pre procceser command .
 # - Pre Processor Directive

#include - Used to import list of declared functions.
           #include<HeaderFile>
           #include "ExternalFileName"

#define - used to define value of constant,MacroName is in capital Letters.
          #define MacroName Value 
          #define MUL(a,b) a*b // creation of function macros ,but in this at place of a and b we can pass only numbers
          #define MAX(a,b) if(a>b) \
                           printf("a is max",a); \
                           else \
                           print("%d is max",b); \
          
#undef - used to undefine the of a constant,it can be used in main function.
         #undef DefinedMacroName

          

-Pre defined Macros

To print Date 
printf("Date %s",__Date__); //mm/dd

To print time
printf("Time %s",__TIME__); //hh/mm/ss

To print file name of code 

printf("File name %s",__FILE__);

To print Line no 

printf("Line %d",__LINE__);

To check compilier is according to ansi compiler

printf("ANSI %d",__STDC__);


          

